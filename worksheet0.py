# -*- coding: utf-8 -*-
"""worksheet0

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IrWTxoiKxUWVn4IczO2fuXmDKMOMgnOM
"""

# Provided Dataset
time_data = [
    (3.5, 2.0, 7.0), (5.0, 1.5, 6.5), (2.5, 3.0, 8.0),
    (4.0, 2.0, 6.0), (1.5, 4.5, 9.0), (3.0, 2.5, 7.5),
    (5.5, 1.0, 6.0), (2.0, 3.5, 8.5), (4.5, 2.0, 7.0),
    (3.0, 3.0, 7.5), (6.0, 1.5, 6.0), (2.5, 4.0, 8.0),
    (4.0, 2.5, 7.0), (5.0, 2.0, 6.5), (3.5, 2.5, 7.0)
]

# 1. Create empty classification lists
low_study = []       # < 3 hours
moderate_study = []  # 3 to 5 hours
high_study = []      # > 5 hours

# 2. Classification of study hours
for study, entertainment, sleep in time_data:
    if study < 3:
        low_study.append(study)
    elif 3 <= study <= 5:
        moderate_study.append(study)
    else:
        high_study.append(study)

# 3. Printing of results
print("Low study hours (<3):", low_study)
print("Moderate study hours (3-5):", moderate_study)
print("High study hours (>5):",high_study)

# Using the lists created earlier
low_count = len(low)
moderate_count = len(moderate)
high_count = len(high)

print("Number of low study days:", low_count)
print("Number of moderate study days:", moderate_count)
print("Number of high study days:", high_count)

# Sample study time data
time_data = [1, 2.5, 3, 4, 5, 6, 7.5, 2, 3.8, 5.2]

# New list to store minutes
study_minutes = []

# 1 & 2. Convert hours to minutes and store in study_minutes
for hours in time_data:
    minutes = hours * 60
    study_minutes.append(minutes)

# 3. Print results
print("Study time in minutes:", study_minutes)

# Sample study time data
time_data = [1, 2.5, 3, 4, 5, 6, 7.5, 2, 3.8, 5.2]

# New list to store minutes
study_minutes = []

# 1 & 2. Convert hours to minutes and store in study_minutes
for hours in time_data:
    minutes = hours * 60
    study_minutes.append(minutes)

# 3. Print results
print("Study time in minutes:", study_minutes)

def sum_nested_list(nested_list):
    total = 0
    for item in nested_list:
        if isinstance(item, list):
            total += sum_nested_list(item)   # recursive call
        else:
            total += item
    return total
nested_list = [1, [2, [3, 4], 5], 6, [7, 8]]
result = sum_nested_list(nested_list)
print("Total sum:", result)

def generate_permutations(s):
    result = []
    used = [False] * len(s)
    s = sorted(s)   # sorting helps avoid duplicates

    def backtrack(path):
        if len(path) == len(s):
            result.append("".join(path))
            return

        for i in range(len(s)):
            # Skip used characters
            if used[i]:
                continue

            # Skip duplicates (important for cases like "aab")
            if i > 0 and s[i] == s[i-1] and not used[i-1]:
                continue

            used[i] = True
            backtrack(path + [s[i]])
            used[i] = False

    backtrack([])
    return result

def calculate_directory_size(directory):
    total_size = 0

    for key, value in directory.items():
        if isinstance(value, dict):
            # value is a subdirectory â†’ recursive call
            total_size += calculate_directory_size(value)
        else:
            # value is a file size (in KB)
            total_size += value

    return total_size
sample_directory = {
    "file1.txt": 200,
    "file2.txt": 350,
    "Documents": {
        "resume.pdf": 120,
        "notes.txt": 80,
        "Projects": {
            "project1.py": 50,
            "data.csv": 300
        }
    },
    "Images": {
        "photo1.jpg": 500,
        "photo2.jpg": 450
    }
}

result = calculate_directory_size(sample_directory)
print("Total directory size:", result, "KB")

def min_coins(coins, amount):
    # Initialize DP array: dp[i] = min coins needed for amount i
    # Use amount+1 as "infinity" since it's impossible to need more than amount coins
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0  # 0 coins needed to make amount 0

    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i:
                dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != amount + 1 else -1

coins = [1, 2, 5]
amount = 11

result = min_coins(coins, amount)
print("Minimum coins needed:", result)

def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    # Create DP table: dp[i][j] = LCS length for s1[0..i-1] and s2[0..j-1]
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Fill the table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
s1 = "abcde"
s2 = "ace"

lcs_length = longest_common_subsequence(s1, s2)
print("Length of LCS:", lcs_length)

def knapsack(weights, values, capacity):
    n = len(weights)
    # Create DP table: dp[i][w] = max value using first i items with capacity w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    # Fill the table
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]

    return dp[n][capacity]
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7

max_value = knapsack(weights, values, capacity)
print("Maximum value achievable:", max_value)