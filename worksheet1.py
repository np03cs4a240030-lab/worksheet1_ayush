# -*- coding: utf-8 -*-
"""worksheet1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IPu2f_nXHorO0O2893iKP08cgU016Ms1
"""

import numpy as np

import numpy as np

# 1. Initialize an empty array with size 2x2
empty_array = np.empty((2, 2))
print("Empty Array 2x2:\n", empty_array)

# 2. Initialize an all-one array with size 4x2
ones_array = np.ones((4, 2))
print("\nAll-one Array 4x2:\n", ones_array)

# 3. Return a new array of given shape and type, filled with a fill value
filled_array = np.full((3, 3), 7)
print("\nFilled Array 3x3 with 7:\n", filled_array)

# 4. Return a new array of zeros with same shape and type as a given array
given_array = np.array([[1, 2, 3], [4, 5, 6]])
zeros_like_array = np.zeros_like(given_array)
print("\nZeros like given array:\n", zeros_like_array)

# 5. Return a new array of ones with same shape and type as a given array
ones_like_array = np.ones_like(given_array)
print("\nOnes like given array:\n", ones_like_array)

# 6. Convert an existing list to a numpy array
new_list = [1, 2, 3, 4]
array_from_list = np.array(new_list)
print("\nArray from list [1,2,3,4]:\n", array_from_list)

import numpy as np

# Task 1: Create an array with values ranging from 10 to 49
arr1 = np.arange(10, 50)
print("array 10 to 49:", arr1)

# Task 2: Create a 3x3 matrix with values ranging from 0 to 8
arr2 = np.arange(9).reshape(3, 3)
print("3x3 matrix:\n", arr2)

# Task 3: Create a 3x3 identity matrix
identity_matrix = np.eye(3)
print("3x3 identity matrix:\n", identity_matrix)

# Task 4: Create a random array of size 30 and find the mean
random_arr= np.random.random(30)
mean_value= random_arr.mean()
print("mean value: ",mean_value)

# Task 5: Create a 10x10 array with random values and find min and max
random_10x10 = np.random.random((10, 10))
min_value = random_10x10.min()
max_value = random_10x10.max()
print("Task 5: Min =", min_value, "Max =", max_value)

# Task 6: Create a zero array of size 10 and replace 5th element with 1
zero_arr = np.zeros(10)
zero_arr[4] = 1
print("Task 6:", zero_arr)

# Task 7: Reverse an array
arr = np.array([1, 2, 0, 0, 4, 0])
reversed_arr = arr[::-1]
print("Task 7:", reversed_arr)

# Task 8: Create a 2D array with 1 on border and 0 inside
array8 = np.ones((5, 5))
array8[1:-1, 1:-1] = 0
print("\n8. 2D array with 1 on border, 0 inside:\n", array8)

# Task 9: Create an 8x8 matrix with a checkerboard pattern
checkerboard = np.zeros((8, 8))
checkerboard[1::2, ::2] = 1
checkerboard[::2, 1::2] = 1
print("Task 9:\n", checkerboard)

import numpy as np

# Given arrays
x = np.array([[1, 2], [3, 5]])
y = np.array([[5, 6], [7, 8]])
v = np.array([9, 10])
w = np.array([11, 12])

# 1. Add the two array.
add_vw= v+w
print ("v+w= ",add_vw)
print()
# 2. Subtract the two array.
sub_xy=x-y
print("x-y= \n",sub_xy)
print()
# 3. Multiply the array with any integers of your choice.
multi_x=x*3
print("x*3= \n",multi_x)
print()
# 4. Find the square of each element of the array.
square= x**2
print("square is : \n",square)
print()

# 5. Find the dot product between: v(and)w ; x(and)v ; x(and)y.
dot_vw = np.dot(v, w)
dot_xv = np.dot(x, v)
dot_xy = np.dot(x, y)

print("v.w",dot_vw)
print("x.v \n",dot_xv)
print("xy \n",dot_xy)

# 6. Concatenate x(and)y along row and Concatenate v(and)w along column.
concat_xy_row = np.concatenate((x, y), axis=0)
concat_vw_col = np.concatenate((v.reshape(-1,1), w.reshape(-1,1)), axis=1)
print("\n6. Concatenate arrays:")
print("x and y along rows:\n", concat_xy_row)
print("v and w along columns:\n", concat_vw_col)

# 7. Concatenate x(and)v; if you get an error, observe and explain why did you get the error?

try:
    concat_xv = np.concatenate((x, v), axis=0)
except ValueError as e:
    print("\n7. Error concatenating x and v:\n", e)
    print("Explanation: x is 2x2 but v is 1D. You cannot concatenate arrays with different shapes along axis 0 without reshaping v.")

import numpy as np

# Given arrays
A = np.array([[3, 4], [7, 8]])
B = np.array([[5, 3], [2, 1]])

# 1. Prove A * A^-1 = I
A_inv = np.linalg.inv(A)
I = np.dot(A, A_inv)
print("1. A * A^-1 =\n", I)

# 2. Prove AB != BA
AB = np.dot(A, B)
BA = np.dot(B, A)
print("\n2. AB =\n", AB)
print("   BA =\n", BA)
print("AB == BA ?", np.array_equal(AB, BA))

# 3. Prove (AB)^T = B^T * A^T
AB_T = (np.dot(A, B)).T
BT_AT = np.dot(B.T, A.T)
print("\n3. (AB)^T =\n", AB_T)
print("   B^T * A^T =\n", BT_AT)
print("Check equality:", np.array_equal(AB_T, BT_AT))

import numpy as np
import time


# 1. Element-wise Addition


size = 1_000_000


list1 = list(range(size))
list2 = list(range(size))

start_time = time.time()
add_list = [a + b for a, b in zip(list1, list2)]
end_time = time.time()
print("Python List Addition Time:", end_time - start_time, "seconds")


arr1 = np.arange(size)
arr2 = np.arange(size)

start_time = time.time()
add_array = arr1 + arr2
end_time = time.time()
print("NumPy Array Addition Time:", end_time - start_time, "seconds")

# 2. Element-wise Multiplication



start_time = time.time()
mul_list = [a * b for a, b in zip(list1, list2)]
end_time = time.time()
print("\nPython List Multiplication Time:", end_time - start_time, "seconds")

start_time = time.time()
mul_array = arr1 * arr2
end_time = time.time()
print("NumPy Array Multiplication Time:", end_time - start_time, "seconds")

# 3. Dot Product


start_time = time.time()
dot_list = sum(a * b for a, b in zip(list1, list2))
end_time = time.time()
print("\nPython List Dot Product Time:", end_time - start_time, "seconds")


start_time = time.time()
dot_np = np.dot(arr1, arr2)
end_time = time.time()
print("NumPy Array Dot Product Time:", end_time - start_time, "seconds")

# 4. Matrix Multiplication



python_matrix_size = 200
numpy_matrix_size = 1000

mat1 = [[i+j for j in range(python_matrix_size)] for i in range(python_matrix_size)]
mat2 = [[i+j for j in range(python_matrix_size)] for i in range(python_matrix_size)]

start_time = time.time()
result_list = [
    [sum(mat1[i][k] * mat2[k][j] for k in range(python_matrix_size))
     for j in range(python_matrix_size)]
    for i in range(python_matrix_size)
]
end_time = time.time()
print(f"\nPython List Matrix Multiplication ({python_matrix_size}x{python_matrix_size}) Time:",
      end_time - start_time, "seconds")

matA = np.arange(numpy_matrix_size**2).reshape(numpy_matrix_size, numpy_matrix_size)
matB = np.arange(numpy_matrix_size**2).reshape(numpy_matrix_size, numpy_matrix_size)

start_time = time.time()
result_np = np.dot(matA, matB)
end_time = time.time()
print("NumPy Matrix Multiplication (1000x1000) Time:", end_time - start_time, "seconds")